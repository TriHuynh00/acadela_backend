options
{
    LOOKAHEAD=2;
}
PARSER_BEGIN(Parser)

import java.util.ArrayList;
import java.util.LinkedList;
import java.io.Reader;

import java.lang.Integer;
import cakeelement.Layer;

public class Parser {
	protected static ArrayList<String> opGroup;
	protected static String cakeType;
	protected static String objType;
	protected static ArrayList<String> keyPairList;
	protected static ArrayList<String> layerKeyPairList;

	protected static LinkedList<Layer> layerList;
	
	public Parser(String s) {
		this((Reader)(new java.io.StringReader(s)));
		
		opGroup     	 = new ArrayList<String>();
		keyPairList 	 = new ArrayList<String>();
		layerKeyPairList = new ArrayList<String>();
		layerList        = new LinkedList<Layer>();
	}
	
	public static void main(String[] args) throws Exception {
		//Exp result = new Parser(new java.io.StringReader(args[0])).S();
		Exp result = new Parser(args[0]).S();
		
		System.out.println(result);
		System.out.println("Cake Type: " + cakeType);
		
		System.out.println(keyPairList);
//		System.out.println(layerKeyPairList);
		for (Layer layer : layerList) {
			System.out.println("layer.position = " + layer.position);
			System.out.println("layer.diameter = " + layer.diameter);
			System.out.println("layer.ingredientList = " + layer.ingredientList);
			System.out.println("layer.hasCream = " + layer.hasCream);
			System.out.println("layer.expression = " + layer.expression);
		}
	}
}

// Classes defining the Abstract Syntax Tree
abstract class Exp {
	public String toString()
	{
		return this.toString();
	}
}

class Num extends Exp {
    int value;
    Num(int v) {value = v;}
    public String toString() {return value + "";}
}

class Str extends Exp {
    String value;
    Str(String v) {value = v;}
    public String toString() {return value;}
}

class TopText extends Exp {
	String txt;
	TopText(Exp text) { txt = text.toString();}
	public String toString()
	{
	  return txt;
	}
}

class BinaryExp extends Exp {
    String op;
    Exp left, right;
    BinaryExp(String o, Exp l, Exp r) {op = o; left = l; right = r;}
    public String toString() {
		Parser.opGroup.add("(" + op + " " + left + " " + right + ")");
		return "(" + op + " " + left + " " + right + ")";
	}
}

PARSER_END(Parser)

SKIP:  { " " | "\t" | "\n" | "\r" }
TOKEN:
	{
	  	"(" | ")" | "+" | "*" | "[" | "]" | ","
	 	| <COMMAND: ("DEFINE") >
		| <FUNCKEY: ("FUNCTION") >
		| <VALIDFUNCTIONSIGN: ("number" | "round") >
		| <COMPARESIGN: ("<" | "<=" | "==" | ">=" | ">") >
	 	| <CHAR: (["A"-"Z","a"-"z"])>
//	 	| <STRING: "'" (<CHAR> | <NUM> |
//	 				(" " | "(" | ")" | "[" | "]" | "{" | "}" | "." | "\"" | "#" | "=" )+ )+ "'">
		| <COLORCODE: "#" (["A"-"F", "a"-"f", "0"-"9"])+ >
		| <NUM: (["0"-"9"])+>
		| <FLOAT: (<NUM> "." <NUM>) >
		| <COLOR: ("red" | "blue" | "green")>
	}

Exp S(): {Exp e;}
{
  e=DefineObj() <EOF> {return e;}
}

//Exp E(): {Exp e1; Exp e2;}
//{
//  e1=T() ("+" e2=T() {e1 = new BinaryExp("+", e1, e2);} )* {return e1;}
//}
//
//Exp T(): {Exp e1; Exp e2;}
//{
//  e1=NumToken() ("*" e2=F() {e1 = new BinaryExp("*", e1, e2);} )* {return e1;}
//}
Exp DefineObj(): {Token e1; Exp e2;}
{
//	<COMMAND> e1=<CAKETYPE> {Parser.cakeType = e1.toString();} e2=TopText() {e2 = new TopText(e2);} { return e2;} // TODO: Create DefineObjExp
//	<COMMAND> e1=<CAKETYPE> {Parser.cakeType = e1.toString();} (e2=KeyPair() | e2=Layer())+ { return e2;} // TODO: Create DefineObjExp 
	<COMMAND> e2=FuncObj() UiRefObj() ColorConditionalAssignment()
	{return e2;}
}

// TODO: Check How Assignments are handle in java
//       Check How to Handle String with "=" sign
//		 READ INPUT FROM FILE

Exp FuncObj(): {Token e1; Exp e2;}
{
	e1=<FUNCKEY> {Parser.objType = e1.toString();} "=" "'" e2=FuncProd() "'"
	{
	  System.out.println("FUNCKEY " + e1);
	  System.out.println("FUNCSIGN " + e2.toString());
  	}
  	{ return e2;}
}

Exp FuncProd(): {Exp e1; Exp e2;}
{
  	{String production = "";}
	e1=FuncExpr() ("+" e2=FuncExpr() {production += new TopText(e2).toString();})* 
	{return new Str(new TopText(e1) + " + " + production);}
}

Exp FuncExpr(): {Exp funcSignature; Token e1; Exp funcElement; Exp extraParam;}
{
	e1=<VALIDFUNCTIONSIGN> { }
	"(" funcElement=Param() { }
		("," extraParam=Param())+ { }
	")"
	{
	  funcSignature = new Str(
	    new Str(e1.toString()) + "("
	    + new TopText(funcElement).toString() + ","
	    + new TopText(extraParam).toString() + ")"
    	);
//	  funcSignature = new Str(
//	    new Str(e1.toString())
//	    + new TopText(funcElement).toString());
	  
    }
    { 
		return funcSignature;
	}
}

Exp Param(): { Exp e1; }
{
  (e1=StrToken() | e1=NumToken() | e1=FuncExpr())    {return e1;}
}

Exp UiRefObj(): {Token e1; Exp e2;}
{
	e1="uiReference" "=" "'" e2=ComparisonExp() "'"
	{
		System.out.println("uiRef " + e2.toString());
	}
	{
		return e2;
	}
}

Exp ComparisonExp(): {Exp e1; Exp e2;}
{
  	{ String phraseExp = ""; }
	(
	  e2=StrToken() {phraseExp = new TopText(e2).toString();}
      |
      (		"colors" "(" e1=NumToken() {phraseExp += new TopText(e1).toString();} (e2=ComparePhrase() {phraseExp += new TopText(e2).toString();})* ")"
	  )
		
	)
	
	{return new Str(phraseExp);} 
}

Exp ComparePhrase(): { Token t1; Token t2; Exp e1;}
{
  	{String word = "";}
	t1=<COMPARESIGN>
	(
	  t2=<COLOR> {word += t2.toString();}
	  | e1=NumToken(){word += new TopText(e1).toString();}
	)//	  t1=<COMPARESIGN> (e1=CharToken() {word += new TopText(e1).toString();})+
	
//	  	  
	  	
	{return new Str(t1.toString() + word);}
}

Exp ColorConditionalAssignment(): { Token t1; Exp e1; Exp e2;}
{
	{
	  String varName = "";
	  String valueStr = "";
    }
	"let"
		((t1=<CHAR>|t1=<NUM>){varName += t1.toString();})*
			"="
				(e1=ConditionalAssignment() | e1=ColorCodeToken()) "in"
	{
	  System.out.println("Assign " + varName + " = " + new TopText(e1).toString());
	  e2 = new Str(varName + " = " + new TopText(e1).toString());
	  return e2;
	}
}

Exp ConditionalAssignment(): { Exp e1; Exp e2;}
{
	(e1=StrWithoutQuoteToken() | e1=CondBlock()) ("+" e2=CondBlock())?
	{return e1;}
}

Exp CondBlock(): { Exp e1; Exp e2;}
{
  	e1=CondStatement()
  	
  	{System.out.println("Variable in if cond: " + e1.toString());}
	{return e1;}
}

Exp CondStatement(): {Exp e1; Exp e2;}
{
	"if" e1=StrWithoutQuoteToken() "=" StrToken() "then" e2=StrToken()
	{return e1;}
}

Exp CondExec(): {Exp e1; Exp e2;}
{
	"if" e1=StrWithoutQuoteToken() "=" StrToken() "then" e2=CondExec()
	{return e1;}
}

//Exp Struct(): { Token e1; Exp e2; }
//{
//	<STRUCTKEYWORD> "=" e2=StructObjAttr() {return e2;} 
//}
//
//Exp StructObjAttr(): { }
//


//Exp KeyPair(): { Token e1; Exp e2;}
//{
//	e1=<KEYWORD> "=" e2=StrToken() {Parser.keyPairList.add(e1.toString() + ":" + e2.toString()); return new Str(e1.toString() + ":" + e2.toString());}
//} 
//
//Exp TopText(): {Exp e1;}
//{
//	<KEYWORD> "=" e1=StrToken() {e1 = new TopText(e1);} { return e1; } 
//}

Exp StringList(): {Exp e1; }
{
	"[" (e1=StrToken() "," )+ "]" { return e1;}
}

Exp NumToken(): {Token t;}
{
  t=<NUM> {return new Num(Integer.parseInt(t.image));}
}

Exp CharToken(): {Token t;}
{
  t=<CHAR> {return new Str(t.toString());}
}

Exp StrToken(): {Token t;}
{
  t="'" (<CHAR> | <NUM> | "(" | ")" | "[" | "]" | "{" | "}" | "." | "\"" | "#" | "=" )+ "'"
  {return new Str(t.toString());}
}

Exp StrWithoutQuoteToken(): {Token t;}
{
  {String strVal = "";}
  (t=<CHAR> { strVal += t.toString();}
   | t=<NUM> { strVal += t.toString();})+
  {return new Str(strVal);}
}

Exp ColorCodeToken(): {Token t;}
{
  t=<COLORCODE>
  {return new Str(t.toString());}
}


