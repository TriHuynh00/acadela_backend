// TODO: Create specific grammar for detecting function
// uiReference, and expressions

Start:
    (versionTag = AcaVersion)?
    (importList *= Import)?

    (
        (defWorkspace = DefWorkspace)
        | ('define' objList *= Obj)*
        // | (objList *= Obj)
    )
;

AcaVersion:
    /(#aca)\d\.\d/
;


// Workspace Definition Level
DefWorkspace:
    workspace = Workspace
    /*(
        (workspaceGlobalObjList *= DefineObj)?
        workspaceProp = DefineCase
    )#*/
    ('define')? (workspaceObj*=Obj)+

;

Workspace:
    WorkspaceTerm BasicIdentity
;

BasicIdentity:
    name = ID
    ('staticId' Eq staticId=STRING)?
;

GroupIdentity:
    name = ID
    (
        ('staticId' Eq staticId=STRING)?
        ('name' Eq groupName=STRING)
    )#
;

DefineCase:
    'define' case=Case
;

DefineObj:
    'define' object=Obj
;

Obj:
    ( Case | CaseSetting | Stage | Task | Form | Field | Hook | ValidAttribute)
;

/********************
******* CASE ********
********************/

Case:
    (
        CaseTerm name=ID
        (
            casePrefix = CasePrefix
            ('version' Eq version = INT)
            // clientPath and ownerPath is defined in CaseSetting
            // Interpreter automatically finds the following attributes:
            // 1. entityDefinitionId (rootEntityDefinitionId):
            //   Case Schema: all entities of settings and stages
            // 2. newEntityAttachPath (entityAttachPath): take path to Settings entity by default
            // 3. newEntityDefinitionId (entityDefinitionId): take Settings entity by default
            //
            (
                description = Description
                responsibilities = Responsibilities
                setting = CaseSetting
                ('Trigger' hookList += CaseHook)?
                summary = SummaryPanel
                //(entityDefinitionId = STRING)?
                //(entityAttachPath = STRING)?
                (notes = STRING)?
            )#
            stageList += Stage
        )#
    ) | (Ref 'Case' ref=[Case|FQN])?
;

CaseSetting:
    (
        SettingTerm
        (description = Description)?
        (
            caseOwner = CaseOwner
            (attrList *= Attribute)
            (casePatient = CasePatient)?
            (attrList *= Attribute)
        )#
    ) | (RefSetting ref=[CaseSetting|FQN])?
;

CaseOwner:
    'CaseOwner' group = TextNoQuote
        attrProp = AttributeProp
;

CasePatient:
    'CasePatient' group = TextNoQuote
        attrProp = AttributeProp
;

/*LinkUserGroupAttr:
    directive = AttributeDirective
    (
        //description = Description
        (attrProp = AttributeProp)?
    )#
;*/


Responsibilities:
    'Responsibilities'
    (
        groupList *= Group
        userList *= User
    )#
;

Group:
    GroupTerm GroupIdentity
;

User:
    UserTerm BasicIdentity
;

ValidAttribute:
    name=ID Eq value=STRING|("'" Function "'")|INT|FLOAT
;

/*****************************
***** ATTRIBUTE SECTION ******
*****************************/

Attribute:
    "attribute" name = ID
    //(

        attrProp = AttributeProp
    //)#
;

AttributeProp:
    directive = AttributeDirective
    (
        description = Description
        (externalId = ExternalId)?
        (additionalDescription = AdditionalDescription)?
        (uiRef = UiReference)?
        (defaultValues = DefaultValues)?
    )#
;

AttributeDirective:
    (multiplicity = Multiplicity)?
    (type = Type)?
;

/***************************
***** SUMMARY SECTION ******
****************************/

SummaryPanel:
    'SummaryPanel' sectionList += SummarySection
;

SummarySection:
    'Section' name = ID
        (directive = SummarySectionPosition)?
        description = Description
        paramList += SummaryParam
;

SummaryParam:
    'InfoPath' path = TextNoQuote
;

/********************
***** HTTPHOOK ******
********************/

Hook:
    CaseHook | HttpHook | DualTaskHttpHook
;

CaseHook:
    (
        ('Hook' name = ID)?
        'On' event = CaseHookEvent
        'invoke' url = STRING
    ) | (RefHook ref=[CaseHook|FQN])?
;

HttpHook:
    (
        ('Hook' name = ID)?
        'On' event = BaseEvent
        (
            ('invoke' url = STRING)
            ('method' method = HttpMethod)
            ('with failureMessage' failureMessage = STRING)?
        )#
    ) | (RefHook ref=[HttpHook|FQN])?
;

DualTaskHttpHook:
    (
        ('Hook' name = ID)?
        'On' event = DualTaskEvent
        (
            ('invoke' url = STRING)
            ('method' method = HttpMethod)
            ('with failureMessage' failureMessage = STRING)?
        )#
    ) | (RefHook ref=[DualTaskHttpHook|FQN])?
;


CaseHookEvent:
    'available'
    | 'enable'
    | 'activate'
    | 'complete'
    | 'terminate'
    | 'delete'
;

BaseEvent:
    'available'
    | 'enable'
    | 'activate'
    | 'complete'
    | 'terminate'
    | 'correct'
;

DualTaskEvent:
    BaseEvent
    | 'activatehumanpart'
    | 'activateautopart'
    | 'completehumanpart'
    | 'completeautopart'
    | 'correcthumanpart'
    | 'correctautopart'
;

CaseDef:
    'casedefinition' caseDefName = ID
;

CasePrefix:
    'prefix' Eq value = STRING
;

MultiAttrModel:
    (attr+=Multiplicity
    attr+=CasePrefix
    attr+=UiReference)#
;

Description:
    ('label' Eq value = STRING)
;


/***********************
******** STAGE *********
***********************/

Stage:
    // Interpreter creates a Stage entity & 2 attributes:
    // 1. entityAttachPath: the Path to the Stage entity
    // 2. entityDefinitionId: The name of the Stage entity
    // activation attribute is "EXPRESSION" if #activateWhen is used

    (
        StageTerm name = ID
            directive = StageElementDirective

            (
                (description = Description)
                (ownerpath = OwnerPath)?
                (clientPath = ClientPath)?
                (dynamicDescriptionPath = DynamicDescriptionPath)?
                (externalId = ExternalId)?
                (additionalDescription = AdditionalDescription)?
                (preconditionList *= Precondition)

            )#

            taskList += Task

    )
    |
    (RefStage ref=[Stage|FQN])?
;

/***********************
******** TASK *********
***********************/

// In a task, activation attribute is "EXPRESSION"
// if #activateWhen is used
Task:
    HumanTask
    | AutomatedTask
    | DualTask
;

HumanTask:
    (
        HumanTaskTerm name = ID
            directive = StageElementDirective
            (
                attrList = SharedTaskAttrs
                ('Trigger' hookList *= HttpHook)?
                form = Form
            )#
    )
    | (RefTask ref=[HumanTask|FQN])?
;

AutomatedTask:
    (
        AutoTaskTerm name = ID
            directive = StageElementDirective
            (
                attrList = AutomatedTaskAttrs
                ('Trigger' hookList *= HttpHook)?
                form = Form
            )#
    ) | (RefTask ref=[AutomatedTask|FQN])?
;

DualTask:
    (
        DualTaskTerm name = ID
            directive = StageElementDirective
            (
                attrList = SharedTaskAttrs
                ('Trigger' hookList *= DualTaskHttpHook)?
                form = Form
            )#
    ) | (RefTask ref=[DualTask|FQN])?
;

AutomatedTaskAttrs:
    (
        description = Description
        (ownerPath = OwnerPath)?
        (externalId = ExternalId)?
        (dynamicDescriptionPath = DynamicDescriptionPath)?
        (additionalDescription = AdditionalDescription)?
        (preconditionList *= Precondition)
    )#
;

SharedTaskAttrs:
    (
        description = Description
        (ownerPath = OwnerPath)?
        (dueDatePath = DueDatePath)?
        (externalId = ExternalId)?
        (additionalDescription = AdditionalDescription)?
        (dynamicDescriptionPath = DynamicDescriptionPath)?
        (preconditionList *= Precondition)
    )#
;

Precondition:
    PreconditionTerm
    (
        // aka. processDefinitionId in Thesis
        ('previousStep' Eq stepList += STRING)*

        // aka. expression in Thesis
        ('condition' Eq entryCondition = STRING)?
    )#
;

/***********************
********* FORM *********
***********************/

Form:
    (
        FormTerm name = ID
            (directive = FormDirective)?
            fieldList += FormField
    ) | (Ref FormTerm ref=[Form|FQN])?
;

FormDirective:
    (
        (mandatory = Mandatory)?
        (readOnly = ReadOnly)?
    )#
;

FormField:
    Field | DynamicField
;

Field:
    (
        'Field' name = ID
            directive = FieldDirective
            (
                (
                    description = Description
                    | question = Question
                )
                (path = FieldPath)?
                (uiRef = UiReference)?
                (externalId = ExternalId)?
                (additionalDescription = AdditionalDescription)?
            )#
    )
    | (Ref 'Field' ref=[Field|FQN])?
;

FieldPath:
    'CustomFieldValue' Eq value=STRING
;

FieldDirective:
    (
        (mandatory = Mandatory)?
        (readOnly = ReadOnly)?
        (position = Position)?
        (multiplicity = Multiplicity)?
        // There is no grammar for DualTask field
        // to avoid overhead in computation, since
        // we expect a large number of fields, and
        // introducing a DualTaskField along with Field
        // will result in longer parsing time
        // The interpreter will check whether a part
        // is included in the DualTaskField instead.
        (part = Part)?
        (type = FieldType)?
    )#
;

DynamicField:
    (
        DynamicFieldTerm name = ID
            directive = DynamicFieldDirective
            (
                description = Description
                (additionalDescription = AdditionalDescription)?
                (uiRef = UiReference)?
                (path = FieldPath)?
                (expression = DynamicFieldExpression)?
                (externalId = ExternalId)?
            )#
    ) | (Ref (FieldTerm | DynamicFieldTerm) ref=[DynamicField|FQN])?
;

DynamicFieldDirective:
    (
        (mandatory = Mandatory)?
        (readOnly = ReadOnly)?
        (position = Position)?
        //(explicitType = PrimitiveDataType)?
        (explicitType = Type)?
    )#
;

Question:
    'Question' Eq text=STRING
    optionList += Option
;

Option:
    'Option' (
        (key=STRING)
        ('value' Eq value=STRING)
        (additionalDescription = AdditionalDescription)?
        (externalId = ExternalId)?
    )#
;

/******************************
****** COMMON DIRECTIVES ******
*******************************/

StageElementDirective:
    (
        (mandatory = Mandatory)?
        (repeatable = Repeatable)?
        (activation = Activation)?
        (multiplicity = Multiplicity)?
    )#
;


/*TaskDirective:
    (
       (mandatory = Mandatory)?
       (repeatable = Repeatable)?
       (activation = Activation)?
       (multiplicity = Multiplicity)?
    )#
;*/

Multiplicity:
    Hash (
        'maxOne'
        | 'exactlyOne'
        | 'atLeastOne'
        | 'any'
    )
;

/*PrimitiveDataType:
    Hash (
        'text' // string
        | 'longtext'
        | 'boolean'
        | NumType
        | DateType
    )
;*/

Type:
    Hash (
        LinkType
        | 'notype'
        | 'text' // string
        | 'longtext'
        | 'boolean'
        | NumType
        | 'singlechoice' // aka. 'enumeration' in Thesis
        | DateType
        | 'json'
        | 'custom'
    )
;

FieldType:
    Type
;

LinkType:
    'link' '.' (linkType='Users' | linkType='Entity')
        '(' linkObj += TextNoQuote (',' linkObj += TextNoQuote)? ')'
;

DateType:
    'date.after(TODAY)'
    | 'date'
;

NumType:
    'number' ('('
        ((comparator=Comparator num=INT) | (min=INT '-' max=INT))
    ')')?
;

Part:
    Hash (
        'humanDuty'
        | 'systemDuty'
    )
;

Repeatable:
    Hash (
        'repeatSerial'
        | 'repeatParallel'
        | 'noRepeat' // default
    )
;

Mandatory:
    Hash (
        'mandatory'
        | 'notmandatory' // Default
    )
;

Activation:
    Hash (
        'manualActivate'
        | 'autoActivate'
        | 'activateWhen' '(' STRING ')'
    )
;

ReadOnly:
    Hash (
        'readOnly'
        | 'notReadOnly' // default
    )
;

SummarySectionPosition:
    Hash (
        'stretched' // Default
        | 'left'
        | 'center'
        | 'right'
    )
;

Position:
    Hash (
        'stretched' // Default
        | 'left'
        | 'center'
        | 'right'
        | 'leftcenter'
        | 'centerright'
    )
;


/***********************
***** SHARED PROPS *****
************************/

AdditionalDescription:
    "additionalDescription" Eq value=STRING
;

DefaultValues:
    'defaultValues' Eq value=WrapValue
;

DynamicDescriptionPath:
    'dynamicDescriptionRef' Eq value=STRING
;

ExternalId:
    'externalId' Eq value = STRING
;

OwnerPath:
    'owner' Eq value = STRING
;

ClientPath:
    'client' Eq value = STRING
;

UiReference:
    'uiRef' Eq
    (
        (
            ("'" value=Function "'")
            | ('"' value=Function '"')
        )
        | value='privatelink'
        | value='hidden'
        | value=STRING
        | (Ref ref=[ValidAttribute|FQN])
    )
;

DueDatePath:
    'dueDateRef' Eq value=STRING
;

ValidFunctionName:
    'number' | 'colors'
;

Function:
    ValidFunctionName
    '('
        (CompareExpression | ParamPattern)
    ')'
;

DynamicFieldExpression:
    // TODO: Create syntax for expression
    'expression' Eq value = STRING
;

FormulaExpression:
    Predicate BasicArithmeticOperators Predicate
;

Predicate:
    ( '(' FormulaExpression ')' )
    | TextNoQuote
    | INT
    | FLOAT
;

ParamPattern:
    Text (',' Text)*
;

CompareExpression:
    NUMBER (Comparator ColorName Comparator NUMBER)+
;

ColorName:
    'red'
    | 'blue'
    | 'green'
    | 'orange'
    | 'yellow'
;

/*********************
******* TERMINAL *****
*********************/

HttpMethod:
    'get'
    | 'post'
    | 'put'
    | 'delete'
;

Comparator:
    '='
    | '<>'
    | '<='
    |'>='
    | '<'
    | '>'
;

BasicArithmeticOperators:
    '+'
    | '-'
    | '*'
    |'/'
;

Quote:
    '"' | "'"
;

Text:
    STRING
;

TextNoQuote:
    /([a-zA-Z0-9-_.])*/
;

// Assignment Sign
Eq:
    '='
;

// Directive Sign
Hash:
    '#'
;

WrapValue:
    '[' (Text | TextNoQuote) ']'
;

Ref:
    'use'
;

RefSetting:
    Ref SettingTerm
;

RefStage:
    Ref StageTerm
;

RefTask:
    Ref TaskTerm
;

RefField:
    Ref FieldTerm
;

RefHook:
    Ref HookTerm
;

FQN: ID+['.'];
FQNI: ID+['.']('.*')?;

// Import Definition Level
Import:
    'import' importURI=FQNI ('as' name=ID)?
    //'import' importVar=ID 'from' path=STRING
;

Comment:
  (/\/\/.*$/
  | /\/\*.*$/
  | /\*.*$/
  | /.*[\*\/]$/ )
;

/**************************
******* I18N TERMINAL *****
***************************/

WorkspaceTerm:
    'Workspace'
;

CaseTerm:
    'Case'
;

SettingTerm:
    'Setting'
;

StageTerm:
    'Stage'
;

TaskTerm:
    'Task'
;

HumanTaskTerm:
    'HumanTask'
;

AutoTaskTerm:
    'AutoTask'
;

DualTaskTerm:
    'DualTask'
;

FormTerm:
    'Form'
;

FieldTerm:
    'Field'
;

DynamicFieldTerm:
    'DynamicField'
;

HookTerm:
    'Hook'
;

UserTerm:
    'User'
;

GroupTerm:
    'Group'
;

PreconditionTerm:
    'Precondition'
;

FormTerm:
    'Form'
;


/********************************************
**** ERROR DETECTION ASSISTANT RULES ********
*********************************************/

// These are the foundational object in SACM. When the
// Syntax Detector scan the lines upward from the error line,
// if it reaches one of these keywords, it will stop scanning

BuildingBlockObject:
    WorkspaceTerm
    | CaseTerm
    | SettingTerm
    | StageTerm
    | HumanTaskTerm | DualTaskTerm | AutoTaskTerm
    | FormTerm
    | FieldTerm | DynamicField
    | GroupTerm | UserTerm
    | PreconditionTerm | HookTerm
;

/*****************
*** OLD SYNTAX ***
******************/

Entity:
    "entity" name = ID
    (
        description = Description
        (attrProp = AttributeProp)?
    )#
    (attrList += AttrList)?
;

AttrList:
    'attributelist'
    (attr += Entity | attr += Attribute)*
    'endAttributeList'
;
