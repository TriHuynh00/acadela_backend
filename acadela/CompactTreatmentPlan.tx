// TODO: Create specific grammar for detecting function
// uiReference, and expressions

Start:
    versionTag = AcaVersion
    (importList *= Import)?
    (
        (defObj *= DefineObj)
        | (defWorkspace = DefWorkspace)

    )#
;

AcaVersion:
    /(#aca)\d\.\d/
;

// Import Definition Level
Import:
    'import' importVar=ID 'from' path=STRING
;

// Workspace Definition Level
DefWorkspace:
    workspace = Workspace
    (
        (workspaceGlobalObj = DefineObj)?
        workspaceProp = DefineCase
    )#
;

Workspace:
    'workspace' BasicIdentity
;

BasicIdentity:
    id = TextNoQuote
    ('staticId' Eq staticId=Text)?
;

GroupIdentity:
    id = TextNoQuote
    (
        ('staticId' Eq staticId=STRING)?
        ('name' Eq name=STRING)
    )#
;

DefineCase:
    'define' case=Case
;

DefineObj:
    'define' object=Obj
;

Obj:
    (Case | Stage | Task | Form | Hook | ValidAttribute)
;

/********************
******* CASE ********
********************/

Case:
    'case' casename = TextNoQuote
    (
        casePrefix = CasePrefix
        ('version' Eq version = INT)
        // clientPath and ownerPath is defined in CaseSetting
        // Interpreter automatically finds the following attributes:
        // 1. entityDefinitionId (rootEntityDefinitionId):
        //   Case Schema: all entities of settings and stages
        // 2. newEntityAttachPath (entityAttachPath): take path to Settings entity by default
        // 3. newEntityDefinitionId (entityDefinitionId): take Settings entity by default
        //
        (
            description = Description
            responsibilities = Responsibilities
            setting = CaseSetting
            ('Trigger' hook += CaseHook)?
            summary = SummaryPanel
        )#
        stage += Stage
    )#
;

CaseSetting:
    'Setting'
    (description = Description)?
    (
        caseOwner = CaseOwner
        (attrList += Attribute)?
        (casePatient = CasePatient)?
        (attrList += Attribute)?
    )#
;

CaseOwner:
    'CaseOwner' group = TextNoQuote
        attrProp = AttributeProp
;

CasePatient:
    'CasePatient' group = TextNoQuote
        attrProp = AttributeProp
;

/*LinkUserGroupAttr:
    directive = AttributeDirective
    (
        //description = Description
        (attrProp = AttributeProp)?
    )#
;*/


Responsibilities:
    'Responsibilities'
    (
        groupList += Group
        userList += User
    )#
;

Group:
    'group' GroupIdentity
;

User:
    'user' BasicIdentity
;

ValidAttribute:
    key=STRING Eq value=STRING
;

/*****************************
***** ATTRIBUTE SECTION ******
*****************************/

Attribute:
    "attribute" name=TextNoQuote
    //(

        attrProp = AttributeProp
    //)#
;

AttributeProp:
    directive = AttributeDirective
    (
        description = Description
        (externalId = ExternalId)?
        (additionalDescription = AdditionalDescription)?
        (uiRef = UiReference)?
        (defaultValues = DefaultValues)?
    )#
;

AttributeDirective:
    (multiplicity = Multiplicity)?
    (type = Type)?
;

/***************************
***** SUMMARY SECTION ******
****************************/

SummaryPanel:
    'SummaryPanel' sectionList += SummarySection
;

SummarySection:
    'Section' id=TextNoQuote
        directive = SummarySectionPosition
        description = Description
        paramList += SummaryParam
;

SummaryParam:
    'InfoPath' path=TextNoQuote
;

/********************
***** HTTPHOOK ******
********************/

Hook:
    CaseHook | HttpHook | DualTaskHttpHook
;

CaseHook:
    'on' event = CaseHookEvent
    'invoke' url = STRING
;

HttpHook:
    'on' event = BaseEvent
    (
        ('invoke' url = STRING)
        ('method' method = HttpMethod)
        ('with failureMessage is' failureMessage = STRING )?
    )#
;

DualTaskHttpHook:
    'on' event = DualTaskEvent
    (
        ('invoke' url = STRING)
        ('method' method = HttpMethod)
        ('with failureMessage is' failureMessage = STRING )?
    )#
;


CaseHookEvent:
    'activate'
    | 'complete'
    | 'terminate'
    | 'delete'
;

BaseEvent:
    'available'
    | 'enable'
    | 'activate'
    | 'complete'
    | 'terminate'
    | 'correct'
;

DualTaskEvent:
    BaseEvent
    | 'activatehumanpart'
    | 'activateautopart'
    | 'completehumanpart'
    | 'completeautopart'
    | 'correcthumanpart'
    | 'correctautopart'
;

CaseDef:
    'casedefinition' caseDefName=TextNoQuote
;

CasePrefix:
    'prefix' Eq value=Text
;

MultiAttrModel:
    (attr+=Multiplicity
    attr+=CasePrefix
    attr+=UiReference)#
;

Description:
    ('description' Eq value=Text)
;

/***********************
******** STAGE *********
***********************/

Stage:
    // Interpreter creates a Stage entity & 2 attributes:
    // 1. entityAttachPath: the Path to the Stage entity
    // 2. entityDefinitionId: The name of the Stage entity
    // activation attribute is "EXPRESSION" if #activateWhen is used
    'Stage' id=TextNoQuote
        directive = StageElementDirective
        (
            (description = Description)
            (ownerpath = OwnerPath)?
            (dynamicDescriptionPath = DynamicDescriptionPath)?
            (externalId = ExternalId)?
        )#
        taskList += Task
;

/***********************
******** TASK *********
***********************/

// In a task, activation attribute is "EXPRESSION"
// if #activateWhen is used
Task:
    HumanTask
    | AutomatedTask
    | DualTask
;

HumanTask:
    'HumanTask' id = TextNoQuote
        directive = StageElementDirective
        attrList = SharedTaskAttrs
        ('Trigger' hookList += HttpHook)?
        formList += Form
;

AutomatedTask:
    'AutoTask' id = TextNoQuote
        directive = StageElementDirective
        attrList = AutomatedTaskAttrs
        ('Trigger' hookList += HttpHook)?
        formList += Form
;

DualTask:
    'DualTask' id = TextNoQuote
        directive = StageElementDirective
        attrList = SharedTaskAttrs
        ('Trigger' hookList += DualTaskHttpHook)?
        formList += Form
;

AutomatedTaskAttrs:
    (
        description = Description
        (ownerPath = OwnerPath)?
        (externalId = ExternalId)?
        (dynamicDescriptionPath = DynamicDescriptionPath)?
        (precondition = Precondition)?
    )#
;

SharedTaskAttrs:
    (
        description = Description
        (ownerPath = OwnerPath)?
        (dueDatePath = DueDatePath)?
        (externalId = ExternalId)?
        (dynamicDescriptionPath = DynamicDescriptionPath)?
        (precondition = Precondition)?
    )#
;

Precondition:
    'Precondition'
    (
        // aka. expression in Thesis
        ('condition' Eq entryCondition = STRING)
        // aka. processDefinitionId in Thesis
        ('previousStage' Eq entryStageList += STRING)+
    )#
;

/***********************
********* FORM *********
***********************/

Form:
    'Form'
        //(id = TextNoQuote)?
        fieldList += FormField
;

FormDirective:
    (
        (mandatory = Mandatory)?
    )#
;

FormField:
    Field | DynamicField
;

Field:
    'Field' id = TextNoQuote
        directive = FieldDirective
        (
            description = Description
            | question = Question
        )
;

FieldDirective:
    (
        (mandatory = Mandatory)?
        (readOnly = ReadOnly)?
        (position = Position)?
        (multiplicity = Multiplicity)?
        // There is no grammar for DualTask field
        // to avoid overhead in computation, since
        // we expect a large number of fields, and
        // introducing a DualTaskField along with Field
        // will result in longer parsing time
        // The interpreter will check whether a part
        // is included in the field instead.
        (part = Part)?
        type = Type
    )#
;

DynamicField:
    'DynamicField' id = TextNoQuote
        directive = DynamicFieldDirective
        (
            description = Description
            (additionalDescription = AdditionalDescription)?
            (uiRef = UiReference)?
            (expression = DynamicFieldExpression)?
            (externalId = ExternalId)?
        )#
;

DynamicFieldDirective:
    (
        (mandatory = Mandatory)?
        (readOnly = ReadOnly)?
        (position = Position)?
        (explicitType = PrimitiveDataType)?
    )#
;

Question:
    'question' Eq text=STRING
     (
        optionList += Option
        (additionalDescription = AdditionalDescription)?
     )#
;

Option:
    'option' key = STRING 'value' Eq value = STRING
;

/******************************
****** COMMON DIRECTIVES ******
*******************************/

StageElementDirective:
    (
        (mandatory = Mandatory)?
        (repeatable = Repeatable)?
        (activation = Activation)?
        (multiplicity = Multiplicity)?
    )#
;


/*TaskDirective:
    (
       (mandatory = Mandatory)?
       (repeatable = Repeatable)?
       (activation = Activation)?
       (multiplicity = Multiplicity)?
    )#
;*/

Multiplicity:
    Hash (
        'maxOne'
        | 'exactlyOne'
        | 'atLeastOne'
        | 'any'
    )
;

PrimitiveDataType:
    'text' // string and longtext combined
    | 'boolean'
    | NumType
    | DateType
;

Type:
    Hash (
        LinkType
        | 'notype'
        | 'text' // string
        | 'longtext'
        | 'boolean'
        | NumType
        | 'selector' // aka. 'enumeration' in Thesis
        | DateType
        | 'json'
    )
;

LinkType:
    'link' '.' (linkType='Users' | linkType='Entity')
        '(' linkObj+=TextNoQuote (',' linkObj+=TextNoQuote)? ')'
;

DateType:
    'date.after(TODAY)'
    | 'date'
;

NumType:
    'number' '('
        ((comparator=Comparator num=INT) | (min=INT '-' max=INT))
    ')'
;

Part:
    Hash (
        'humanDuty'
        | 'systemDuty'
    )
;

Repeatable:
    Hash (
        'repeatSerial'
        | 'repeatParallel'
        | 'noRepeat' // default
    )
;

Mandatory:
    Hash (
        'mandatory'
        | 'notmandatory' // Default
    )
;

Activation:
    Hash (
        'manualActivate'
        | 'autoActivate'
        | 'activateWhen' '(' STRING ')'
    )
;

ReadOnly:
    Hash (
        'readOnly'
        | 'notReadOnly' // default
    )
;

SummarySectionPosition:
    Hash (
        'stretched' // Default
        | 'left'
        | 'center'
        | 'right'
    )
;

Position:
    Hash (
        'stretched' // Default
        | 'left'
        | 'center'
        | 'right'
        | 'leftcenter'
        | 'centerright'
    )
;


/***********************
***** SHARED PROPS *****
************************/

AdditionalDescription:
    "additionalDescription" Eq value=STRING
;

DefaultValues:
    'defaultValues' Eq value=WrapValue
;

DynamicDescriptionPath:
    'dynamicDescriptionRef' Eq value=STRING
;

ExternalId:
    'externalId' Eq value = STRING
;

OwnerPath:
    'owner' Eq value = STRING
;

UiReference:
    'uiRef' Eq value=Function
;

DueDatePath:
    'dueDateRef' Eq value=STRING
;

ValidFunctionName:
    'number' | 'colors'
;

Function:
    ValidFunctionName
    '('
        (CompareExpression | ParamPattern)
    ')'
;

DynamicFieldExpression:
    // TODO: Create syntax for expression
    'expression' Eq expression = STRING
;

FormulaExpression:
    Predicate BasicArithmeticOperators Predicate

;

Predicate:
    ( '(' FormulaExpression ')' )
    | TextNoQuote
    | INT
    | FLOAT
;

ParamPattern:
    Text (',' Text)*
;

CompareExpression:
    INT (Comparator ColorName Comparator INT)+
;

ColorName:
    'red'
    | 'blue'
    | 'green'
;

/*********************
******* TERMINAL *****
*********************/

HttpMethod:
    'get'
    | 'post'
    | 'put'
    | 'delete'
;

Comparator:
    '='
    | '<>'
    | '<='
    |'>='
    | '<'
    | '>'
;

BasicArithmeticOperators:
    '+'
    | '-'
    | '*'
    |'/'
;

Quote:
    '"' | "'"
;

Text:
    STRING
;

TextNoQuote:
    /([a-zA-Z0-9-_.])*/
;

// Assignment Sign
Eq:
    '='
;

// Directive Sign
Hash:
    '#'
;

WrapValue:
    '[' (Text | TextNoQuote) ']'
;

Comment:
  (/\/\/.*$/
  | /\/\*.*$/
  | /\*.*$/
  | /.*[\*\/]$/ )
;

/*****************
*** OLD SYNTAX ***
******************/


Entity:
    "entity" name=TextNoQuote
    (
        description = Description
        (attrProp = AttributeProp)?
    )#
    (attrList += AttrList)?
;

AttrList:
    'attributelist'
    (attr += Entity | attr += Attribute)*
    'endAttributeList'
;


